# √çndice Brin
Projeto acad√™mico de Banco de Dados ‚Äî An√°lise pr√°tica do uso de √≠ndices BRIN em tabelas massivas de sensores IoT utilizando PostgreSQL.

## Objetivo

Demonstrar, de forma pr√°tica e comparativa, o funcionamento do √≠ndice **BRIN (Block Range Index)** em cen√°rios com bilh√µes de registros, explicando:

- O que s√£o √≠ndices no PostgreSQL
- Diferen√ßas entre **BRIN** e **B-Tree**
- Casos em que o BRIN √© mais vantajoso
- Ganhos em desempenho e economia de espa√ßo em disco

## Estrutura do Projeto

- Cria√ß√£o da tabela de sensores
- Inser√ß√£o de dados com `generate_series`
- Cria√ß√£o e remo√ß√£o dos √≠ndices B-Tree e BRIN
- Consultas com e sem √≠ndice, usando `EXPLAIN ANALYZE`
- Prints das execu√ß√µes para compara√ß√£o de desempenho
- Tabela com os tamanhos dos √≠ndices em diferentes volumes

### O que √© um √≠ndice?

Um **√≠ndice** √© uma estrutura auxiliar que acelera a busca por dados em tabelas. Funciona como o √≠ndice de um livro: ao inv√©s de ler todas as p√°ginas (linhas da tabela), voc√™ vai direto ao ponto.

### √çndice B-Tree

- Organiza os dados de forma ordenada
- Ideal para buscas espec√≠ficas ou intervalos pequenos
- Mais preciso, mas consome muito espa√ßo

### √çndice BRIN

- Divide a tabela em **blocos de p√°ginas** (por exemplo, de 128KB)
- Armazena o **m√≠nimo e m√°ximo** de cada bloco para a coluna indexada
- Ideal para dados **ordenados fisicamente** (ex: logs, datas)
- Extremamente leve

---

## Demonstra√ß√£o Pr√°tica

### Cria√ß√£o da Tabela

```sql
CREATE TABLE sensores (
  id SERIAL PRIMARY KEY,
  data_hora_evento TIMESTAMP,
  tipo TEXT,
  valor DOUBLE PRECISION
);
```
### Resumo dos campos:
- **id**: identificador √∫nico de cada registro.
- **data_hora_evento**: registra quando o dado foi coletado.
- **tipo**: tipo do sensor (temperatura, umidade, etc).
- **valor**: valor da leitura do sensor.

### Inserindo os dados
```sql
INSERT INTO sensores (data_hora_evento, tipo, valor)
SELECT 
    NOW() + (s * INTERVAL '1 second'),
    CASE 
        WHEN s % 3 = 0 THEN 'temperatura'
        WHEN s % 3 = 1 THEN 'umidade'
        ELSE 'pressao'
    END,
    CASE 
        WHEN s % 3 = 0 THEN 20 + random() * 15
        WHEN s % 3 = 1 THEN 40 + random() * 60
        ELSE 980 + random() * 40
    END
FROM generate_series(1, 200000000) AS s;
```
Este script insere 20 milh√µes de registros simulados, alternando entre sensores de temperatura, umidade e press√£o.
Voc√™ pode ajustar a quantidade modificando o valor final em generate_series(1, 20000000).

## Consultas com EXPLAIN ANALYZE

### Sem √≠ndice (Sequential Scan)

- Leitura completa da tabela  
- Muito lento para grandes volumes

Sem √≠ndice, o banco de dados realiza uma varredura sequencial, o que compromete o desempenho das consultas.  
A cria√ß√£o de um √≠ndice B-Tree melhora consideravelmente a velocidade ao buscar por colunas indexadas, como `data_hora_evento`.

### Criar e Medir √çndice B-Tree
```sql
CREATE INDEX idx_btree ON sensores (data_hora_evento);
SELECT pg_size_pretty(pg_relation_size('idx_btree'));
```
Ap√≥s a cria√ß√£o do √≠ndice, o segundo comando retorna o espa√ßo ocupado por ele no disco.
Com 20 milh√µes de registros, o √≠ndice B-Tree gerado ocupou aproximadamente 4284 MB (ou 4,284 GB).

### Consulta com √çndice B-Tree

```sql
EXPLAIN ANALYZE
SELECT * FROM sensores
WHERE data_hora_evento BETWEEN '2026-03-02 00:00:00' AND '2026-10-30 23:59:59';
```
üïí Tempo de execu√ß√£o: entre 15 a 20 segundos.

### Consulta com √çndice Brin
```sql
EXPLAIN ANALYZE
SELECT * FROM sensores
WHERE data_hora_evento BETWEEN '2026-03-02 00:00:00' AND '2026-10-30 23:59:59';
```
üïí Tempo de execu√ß√£o: entre 10 a 12 segundos.

## An√°lise Comparativa
O resultado do `EXPLAIN ANALYZE` fornece dados importantes para comparar o desempenho dos √≠ndices BRIN e B-Tree em consultas sobre grandes volumes de dados.
Para facilitar a compreens√£o, criei a tabela abaixo que resume a performance de cada √≠ndice.

| Crit√©rio                 | **BRIN**         | **B-Tree**      | Melhor     |
| ------------------------ | ---------------- | --------------- | ---------- |
| **Tipo de leitura**      | Bitmap Heap Scan | Index Scan      | Depende    |
| **Blocos lidos (lossy)** | 161.536 blocos   | Linhas precisas | BRIN       |
| **Linhas retornadas**    | 20.995.199       | 20.995.199      | Igual      |
| **Planejamento**         | 0.121 ms         | 0.345 ms        | BRIN       |
| **Tempo total**          | 10.2 segundos    | 15.8 segundos   | BRIN       |

Em algumas situa√ß√µes, consultas espec√≠ficas podem se beneficiar mais do √≠ndice B-Tree, principalmente quando a precis√£o na leitura de dados √© priorit√°ria.  
O √≠ndice BRIN, por sua vez, √© uma estrutura leve que funciona muito bem para tabelas gigantes com dados ordenados fisicamente, sendo bastante usado em cen√°rios como logs de sensores e dados temporais com inser√ß√£o sequencial.

## Conclus√£o

- O √≠ndice **BRIN** n√£o substitui o **B-Tree** em todos os casos, mas √© excelente para tabelas muito grandes com colunas ordenadas.
- √â ideal para logs de sensores, dados temporais e cen√°rios de inser√ß√£o sequencial.
- Proporciona um ganho significativo de espa√ßo, reduzindo o tamanho do √≠ndice de centenas de MB para poucos KB.
- Melhora consideravelmente o tempo de resposta em consultas por intervalo de dados.

### Quando usar BRIN?

- Quando os dados possuem ordem f√≠sica natural (ex: por data ou ID sequencial)
- Para consultas que filtram por intervalos grandes
- Em situa√ß√µes que exigem economia de espa√ßo no armazenamento de √≠ndices

